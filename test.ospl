*****
this 
is
a
multiline
comment
*****

# this is a single line comment

def add = fn((a, b), c) {
    def z = a + b + c;
    return z;
};
print "hello world!\n";

def result = add((1, 2), 6);
if result == 6 {
    print "result is equal to 6\n";
} else if result < 6 {
    print "result is less than 6\n";
} else if result > 6 {
    print "result is greater than 6\n";
} else {
    print "unreachable\n";
};

def a = 0d;
a = 1d;

select result {
    case ([6]) {
        print "result is 6\n";
    }

    case (_) {
        print "result isn't 6\n";
    }
};

# FFI: demonstrate both traditional and CFFI syntax
import 'example' './libexample.so';
def add_two = foreign 'example' 'add_numbers'(i32, i32) -> i32;
def cos_fn = foreign 'example' 'cosine'(f64) -> f64;

# Using explicit 'd' suffix for u32 literals in FFI calls
print "add_numbers(3, 4) via ffi => ";
print add_two(3d, 4d);
print "\n";
print "cos(0.0) from ffi: ";
print cos_fn(0.0f);
print "\n";

# CFFI convenience syntax
def example_lib = OSPL_CFFI_Load './libexample.so';
def cffi_add = OSPL_CFFI_Fn example_lib.add_numbers (i32, i32) -> i32;
def cffi_cos = OSPL_CFFI_Fn example_lib.cosine (f64) -> f64;

# Property access / thisref regression checks
def assert_eq = fn(expected, actual, label) {
    if expected == actual {
        print "PASS: ";
        print label;
        print "\n";
    } else {
        print "FAIL: ";
        print label;
        print " expected ";
        print expected;
        print " got ";
        print actual;
        print "\n";
    };
};

def x = obj {
    id: "x",
    y: fn(?this, $value) {
        def self = @this;
        return self.id;
    },
    z: fn(?this) {
        def self = @this;
        return self.id;
    }
};

def a_obj = obj {
    id: "a",
    b: obj {
        id: "b",
        c: fn(?this) {
            def self = @this;
            return self.id;
        }
    }
};

assert_eq("b", a_obj.b.c(), "inner call binds thisref to nested object");
assert_eq("x", x.y(a_obj.b.c()), "thisref survives nested call argument");
assert_eq("x", x.y(a_obj.b), "thisref survives property access argument");
assert_eq("x", x.y(x.z), "thisref survives sibling property argument");
